
[概述](https://zhuanlan.zhihu.com/FITStory)

## 概述
做市商的定价过程，完整地叙述，就是接受市场价格信息，根据某种预先定义的规则（规则内嵌在定价模块里或者被引用的外部模块中），生成一组或者多组ask/bid价格，经过检验无误后提交给市场下单模块。
这么说比较枯燥，不妨用列表表示。
1. 理论定价（theoretical pricing） : 根据标的资产的价格生成需定价的期权的理论价格
2. 微调（shifting）: 对理论价格进行调整，加上偏差（bias), 这一步也可以叫做微调
3. 生成买卖差价（spreading）: 根据步骤2调整后的理论价格，生成bid/ask 报价。做市商提供的报价包括卖价和买价。
4. 买卖差价再调整（ask/bid shifting）: 根据预定义规则，对bid/ask价格各加上偏差(bias)
5. 调整价格格式（tick rounding）: 根据四舍五入原则对bid/ask价格进行处理, 并且处理锁报价和交叉报价这两种无效报价情况。
6. 检验（verfication）: 最后检验是否符合交易市场的价差要求，输出最终报价bid/ask
可以看到，报价过程是一个流水线。虽然看上去简单，实际却是交易系统的核心。作为高速流动市场上的做市商，她必须能以毫秒级别的速度处理输入报价，定价并输出报价到交易引擎。所以每个步骤写的明确。


[生成理论价格](https://zhuanlan.zhihu.com/p/25673286)
## 生成理论价格

之前概括中，没有细说的是一个完整的期权定价过程以标的合约价格，`历史波动率`，`无风险利率`，`股息`（如果有的话）`行权价格和到期时间`为输入，以符合市场规则的期权bid/ask 报价为输出。

所以第一步就是输入标的合约的价格和其他参数，使用定价模块输出理论价格。如果我们约定无风险利率保持在3%，对于期货期权股息可以忽略，到期时间和行权价格在当日都属于不变参数。唯一可能变化的是历史波动率和标的合约价格。历史波动率的话，我们可以认为根据每天的收盘价（或结算价）计算得出。例如如果是还有3个月到期的期货的期权，那么就计算90天的历史波动率。因此在当日交易直到收盘前，历史波动率也是不变的。

唯一可变的就是标的合约的市场价格了。 对于ETF期权来说，就是ETF的价格。对于期货期权来说，就是对应的期货合约价格。例如期权m1705-C-2750 对应的是17年五月份结束交易的豆粕合约。所以标的合约的市场价格被当作理论价格的主要输入变量。

期货期权理论价格的计算，通常用改进过的B-S(中文名毕苏）方程计算即可。理论计算出来的价格与市场上实际交易的价格肯定是有偏差的。这个偏差直接体现在了隐含波动率和计算使用的历史波动率之间的差异。所以在理论价格生成后，下一步就是对理论价格进行微调而不是直接报价。现在我们先集中精力研究如何生成理论价格。

第一种方法是精确定价，这种方法的特点是根据某种模型直接计算出理论价格。例如BS模型等等，用在期权类衍生品上非常合适。模型算法可以放在外部模块中，被定价引擎调用。特点是精确（特别注意，仅仅是理论上的精确，并不代表符合实际市场）。缺点是对模块性能要求很高。实际市场的标的合约价格变动是以毫秒为级别，行情推送则以500毫秒为一个tick。即使其他所有剩下的定价步骤只需要100毫秒，那么在400毫秒中，计算引擎必须调用外部的模块计算一个微分方程。更糟糕的是，由于模块之间的函数调用需要涉及到动态链接库，这本身就需要额外的时间。因此一个精确定价的模块，必须使用C语言或者C++语言编写，并且经过编译器优化后被调用。 目前比较流行的开源模块有基于boost的 QuantLib。链接如下：
a free/open-source library for quantitative finance
如果用户需要非常精确的理论价格，并且程序编写能力非常好，在秒级别的报价中，可以考虑使用这种方法。

第二种方法比较作弊。它假设期权的Delta 和Gamma在一个极短间隔，例如毫秒级别是不变的。因此我们利用最近的历史期权价格和历史Delta, Gamma生成新的期权价格。
具体地说，由于期货合约每天的价格变动在一个区间内，例如结算价的正负4%，历史波动率和其他信息已知，我们完全可以预先计算好对应标的合约每个整数价格，例如2000，2001。。。2010.。。。的期权价格, Delta, Gamma。如果你有兴趣，也可以生成Vega。每个标的合约的价格对应的是一个向量，向量包含了标的合约价格S，理论价格P, 期权的Delta, 期权的Gamma。这些向量存在一个矩阵或者其他快速检索的数据结构中，并在当日交易时提前被调入内存等待使用。
一旦理论价格生成模块获取到最新的标的合约市场价格时，它首先寻找向量组中是否已存在该价格。如果存在，就直接返回。如果不存在，就获取与当前价格最接近的一组向量（例如100.1选择100，100.9选择101，100.5可以选择100或者101），最终通过线性插值计算得出理论价格。这种方式的特点是简单实用，适用于许多简单的金融合约，例如期权。如果实时计算，则非常耗时。计算机科班出身的朋友，一定看出来，这就是经典的空间换时间。使用伪代码显示如下
def theoPriceGen (spotPrice=s):
#使用插值法生成理论价格，输入s为原始价格
    
    #如果存在vector[s]，则直接返回对应的理论价格
    if vector[s] <> NULL
        return vector[s].price
#如果没有s的预存值，则返回与s值最近的一个向量record
    #例如s=100,s0=99，其他值都小于99，因此s与s0之间的距离最近
record=getVector(s)
    delta0=record.delta  #预先设定  
    gamma0=record.gamma #预先设定
    s0=record.s0
    p0=record.p0
#按照delta, gamma的定义计算价格，这里假定这两个参数在短间隔内不变。
    price=p0+delta*(s-s0)+0.5*gamma*(s-s0)**2    
    return price
插值法的特点是快速。特别适合毫秒级别的计算。如果采用字典设计，那么该函数的调用时间实际上是O(1)。粗略地可以理解为常数时间。但是空间代价则是O(n)。粗略可以理解为随着价格个数的增加线性增长。不同于期货，对应于一份期货合约，期货期权可能有几十种合约。那么对应市场上几百种期货合约，期货期权就会有上万种。每种合约的当日价格变动就有几十个间隔单位。好在现代服务器高达100GB以上的内存可以同时保持这么多期权向量组。
第三种方法适用于一类特殊的产品，市场上叫做Delta One。意思是衍生品价格变动值和标的资产价格变动值呈简单的线性关系，没有二次或者二次以上的项。使用伪代码表示如下
def theoPriceGen(spot=s):
    #a,b 为预先定义
    price=as+b
    return price
可以看到，这种方式比插值法还简单。实际使用中，比较适合两种极为相似的产品。
第四种方法比较特殊。需要计算的期权价格可以直接从市场上的另一种期权的价格得到。
def theoPriceGen4(priceOnMkt):
  
    #definedShift 是预先定义的偏移量
    #priceOnMkt 是从市场上获取的另一种期权的价格
    price=priceOnMkt+definedShift
    return price
我们可以想象一个场景，市场上有一对极其相似的期权合约，两者之间的价格差稳定在一个值上。因此得知其中一个合约的价格，就可以直接计算出另一个合约的价格。那么第四种方法就可以用于这种情况。

[数据奶源](https://zhuanlan.zhihu.com/p/25674694)
## 数据奶源

并非所有的牛奶都叫做特仑苏；`并非所有的合约价格都用来理论定价`。
我们之前说的是一个理想状态，原始价格有效，算法正常，得到的理论价格也有效。然而真实情况下，网络可能会中断，合约报价可能会无效等。当碰到以下情况时，期权定价引擎就没有必要使用当前的合约价格计算理论价格（同理也不需要生成ask/bid报价），而是等待下一个有效的标的合约价格。

如果我们写过策略算法，就对两个概念不陌生。一个是短柱Bar。每个Bar代表了一个时间段内的至少五个值： 开始价格，最低价，最高价，结束价和成交量。 另一个则是Tick，表示最短时间的单独报价。如果是CME，Tick返回的是实时成交信息，即每一个时间点的成交记录。国内期货交易所则使用规定间隔的毫秒数返回一组价格和间隔内的成交信息。例如股指期货，我们每500毫秒从CTP获取一个Tick行情。

无论是Bar和Tick，当你收到这些价格信息时，策略都需要做一些事情，决定是否下单，如何下单。这些就构成了你策略中的交易信号部分。同理，理论定价模块也需要在收到一个Bar或者Tick后，并且在下一个Bar或者Tick还没有到来之前，完成理论价格的计算。 那么问题就来了，现实可能发生各种情况，导致合约价格并不能用来计算理论价格。比如

价格过期，你收到的价格已经落后了实际价格若干个周期，这样情况下，你计算的理论价格自然只能落后于实际价格更多个周期。 造成这样的原因非常多，比如最常见的网络原因。
价格无效，你收到的价格未必有效。这个在现实中不太可能。交易所发布的合约价格通常是有效的。除非你连接上了一个假的交易所，：）
接下来的两个情况，是做市商特有的顾虑。不同于交易者，做市商希望的是价格的稳定，而非大起大落。因为做市商的利润来源于价差和交易所可能的返佣。如果价格剧烈波动，那么可能做市商会持有单边多头或者空头而无法以平稳可预期的价格平仓。恰好如果有人发现他们的大额平仓需求需要尽快满足，就可以嘿嘿嘿，你懂的。总之这对于需要维持高流动性的他们来说是极为不可接受的。但是如果你是追求利润的基金或者经验丰富的投机者，价格剧烈波动就意味着盈利机会，期权的定价自然需要反应出这种变化。因此接下来的两个情况，你会认为价格依然有效。

价格本身超过一定范围，例如一些异常的价格信息。并非所有的合约价格信息都需要用来计算理论价格。如果市场合约价格突然波动有点偏大，那么可能发生了一些我们不知道的事情，价格突然被拉高又瞬间被拉回，或者反之。这样异常的事件，是否值得为其计算理论价格，见仁见智。有的人认为这是属于市场价格，交易员不应该用自己的偏见去忽视其存在，波动性高证明存在获利可能。也有人认为交易员根据自己的经验，知道这些只是噪音，不值得关注。所以这是一个没有标准答案的问题。做市商不喜欢这样的价格变动，对冲基金和有经验的投机者则趋之若鹜。
合约的波动率范围超过预先设置的值，这同上。假设我们根据过去的交易经验，认为100个Tick内，合约价格的历史波动率的值保持在一个区间内。如果当前Tick数据导致最近的历史波动率超过这个区间，那么做市商可以认为这个值无效。当然投机者依然会喜欢这样的波动。
此外还有一个比较例外。如果你需要保持Delta中性，当期货持仓量为0时，自然也没有必要保持期权头寸了。因此也就没必要计算理论价格及报价了。

当以上情况发生后，理论定价模块可以等待下一个价格输入。
过犹不及，价格即使有效，如果数量太多，也有可能会导致定价模块过载。计算需要时间，大量价格到来，可能导致价格的计算频率跟不上行情的变化频率。因为语言和操作系统的设计风格，定价软件也有最大负荷量，超过这个量可能会增加软件系统故障率，例如进程死，各种溢出、等待。 为了防止这些情况，一些软件也允许忽略一部分价格。这个过程被叫做消噪。当然，你也可以调整行情价格的频率，例如从500毫秒到5秒钟。大部分软件在5秒内足够完成你需要的任何定价操作，即使是最为复杂的期权定价微分方程。

说起消噪方法，例如

限制相邻价格的最大变化范围
限制价格更新的频率，就像我们说的从500毫秒到5秒。
如果计算出的理论价格变化和上一个理论价格相比，变化在一个很小的范围内，例如小数点后三位，那么就丢弃该理论价格，沿用上一个理论价格（这是在计算理论价格后的丢弃，和前两者不一样）

[Bid/Ask](https://zhuanlan.zhihu.com/p/25701239)

## Bid/Ask 价格

国内证券市场的场内交易使用的是集中竞价和连续竞价制度。交易系统负责将价格相同的买单和卖单撮合在一起成交。这期间并没有做市商的存在。而银行间的外汇市场则存在做市商制度。做市商负责对流动性的货币对进行买入和卖出报价，赚取价差。 做市商的买入价叫做bid, 做市商的卖出价叫做ask。需要注意的是，bid/ask与国内证券市场的申买/申卖价完全不一样。 后者是投资者的限价单的价格，由投资者提出。前者则是做市商提供给市场的报价，投资者可以按照ask价买入，按照bid卖出。ask-bid 的值即为价差。价差为正，则做市商赚钱，价差为零，则做市商无利可图。价差为负，做市商可能赔钱。之所以说可能，是因为做市商可以依靠交易所的补贴过活。
期货期权市场如今引入了做市商制度。按照大商所的规定：

做市商双边报价分为持续报价和回应报价。

（一）持续报价。在期权交易时间内，做市商按协议约定，主动提供的持续性双边报价。

（二）回应报价。在期权交易时间内，做市商按协议约定，对收到询价请求的期权合约，进行的双边报价。

双边报价就是Bid/Ask 报价。

接下来我们介绍生成Bid / Ask 价格的步骤。首先定义一个价差值shift, 接着理论价格减去这个价差值的一半，就是bid价格，理论价格加上这个价差值的一半就是ask价格。听起来很简单，实际就是很简单。 这个价差值的选择，就是做市商对市场的判断了。如果市场流动性好，那么价差值小一些，如果市场流动性差，价差值就大一些。

说到这里，我想起了 一本交易方面的经典教材，将限价单看作一个期权。挂出限价单的一方有义务成交，是期权的卖方。看到限价单的一方有选择的权利，是期权的买方。限价单劣于市场当前最好价格的部分，就是期权的权利金。

如果我们用这个比喻，看看做市商的行为。当他挂出Bid / Ask 报价时，他就有义务按照上面的价格成交。这就意味着他同时卖出了一个看涨期权和一个看跌期权。这组合起来就是一个跨式齐全。所以做市商实际是卖出了一个跨式期权。 那么卖出跨式的一方自然希望价格在一个范围内，例如价差值内波动，这样他就能获取 Ask-Bid=Shift 的权利金。如果市场流动性好，那么价格往往是在一个平稳的范围内波动，做市商就可以很轻松地建立这个组合头寸；但是如果市场流动性差，做市商可能只能成交单方向限价单，或者说跨式组合的一个腿被执行，另一个腿却无人问津，裸头寸的风险立刻升高。

为了弥补单边成交的风险，做市商就需要加大Bid / Ask的价差。如果他买入了一手，就要求以更高的价格卖出；同理，他卖出了一手，就要求以更低的价格买入。 流动性的好坏体现了价差的优劣上。

Okey，BB完了，以上纯属臆测。我们接下来看伪代码。我们用shift表示价差，因为价差无非是作用在报价上的一个偏移量。计算机学科里喜欢shift, 这个是汇编语言遗留的习惯。而价差在交易中的俗称是spread。

ask-bid=(theorectical_price+1/2*shift)-(theorectical_price- 1/2*shift)
化简后为
ask-bid=shift

这里的theorectical_price是已经微调后的理论价格
不过应用时，可以做一些变化，以适应不同的需求。第一种变化就是选择报价中哪一方改变。

平均方式： ask和bid同时改变相同的量
bid=theorectical_price - 1/2*shift
ask=theorectical_price + 1/2*shift
变动Ask方式：只有ask改变，bid价格直接等于理论价格
bid=theorectical_price 
ask=theorectical_price + shift
变动Bid方式，ask价格直接等于理论价格
bid=theorectical_price- shift
ask=theorectical_price
经验方式：除了shift值，再引入一个根据市场观察得来的变量var
bid=theorectical_price - 1/2*(shift+var)
ask=theorectical_price + 1/2*(shift+var)

[bid ask 再平衡](https://zhuanlan.zhihu.com/p/25712370)

## Bid ask 再平衡

做市商的Bid /Ask 价格生成后，可能需要根据市场情况进行再调整。例如基于义务，做市商必须对某合约进行报价，但他不情愿对此报价，也不想牺牲价差。此时，他可以单方面提高Ask价，或者单方面降低Bid价格，生成一对离市场最佳价格较远的报价。

另一种情况是做市商按照Bid合约买了一笔期权合约后，市场突然发生了剧烈波动，假设是价格迅速下降。为了让他手上的合约迅速出货，Ask价格必须能够适应新的下行价格。因此Ask价格和Bid可以不对称地减去偏移值。例如bid价格减去4个最小单位，Ask减去6个最小单位。通过牺牲2个基本单位的价差，做市商希望尽快将手头的头寸出清。

具体地做法是预先定义，或者根据市场情况实时计算一个偏移量进行调整。调整过程也很简单。

以单边调整bid价格举例，调整幅度是bidShift

bidShift为报价的数量值
bid = bid+bidShift
bidShift为价格的百分比，
bid = bid*(1+bidShift)
需要注意的是，期权的价格不仅仅体现在它的报价上，也体现在它的隐含波动率上。因此如果我们也可以通过调整历史波动率的值，试图跟上市场变化。具体做法就是将vega值乘以某个偏移量。

bid=bid+ (bidShift*vega)  
当然，对付市场的不可预知波动，手工的调整也是不可避免的。根据历史数据或者经验，将偏移量设定为一个固定值，可以应付大部分时间的市场波动，但是这不能代替异常波动的紧急手工处理。在1987年美国股灾时，NASDAQ的许多做市商拒绝给出报价，或者只给出单边报价。这就是手工操作的必要性。


[四舍五入](https://zhuanlan.zhihu.com/p/25728247)
## 四舍五入

当生成了一对bid/ask价格后，交易员需要对价格做一些调整。例如最简单的就是四舍五入。这个步骤存在的原因是，计算机生成的价格通常是小数点之后七位的浮点数。实际交易市场会根据合约品种的不同，设置不同的精确度。 有的是整数，例如期货市场上的一些商品合约，有的是小数点后两位，例如股票价格。另一种情况是有的合约价格的末尾数规定必须是偶数，或者是奇数，或者是某些特定的数。例如曾经美国股票的价差被规定为1/8的整数倍，那么价格末尾就是0.125，0.25，0.375，0.5，0.625，0.75,0.875和0这六种可能。

因此这一步骤就是根据不同的合约规则，将价格转换成不同期权品种要求的报价格式。

具体做法，可以设置一些预定义对应于合约的规则，当对该合约进行报价时，规则就发生作用。例如可以设置一个对应的字典或者数据库表，对应于不同的规则：

rule_dict={"SROption":{"rule_id":body of rule},
           "50ETFOption":{"rule_id":body of rule,
           .....
          }
当需要调整格式时，则可以用以下函数伪代码：

def price_rounding(contract,rule_id,bid_ask_pair):
   
    ...... 
    #获取对应规则的处理函数 function_handler
    rule=rule_dict[contract]
    function_handler=rule[rule_id]

    # 传入bid/ask,生成符合需求的bid_ask报价对
    return function_handler(bid_ask_pair)。
   
除了四舍五入外，格式调整这一步，也可以和消噪合并起来。当bid或者ask的波动性并没有超过预先定义的阈值时，则不会更改bid/ask值。结合刚才的四舍五入过程，我们用以下代码表示过程

def price_rounding(contract,rule_id1,[bid,ask]):
   
   #生成上一次bid的波动区间
    bid_low=last_bid -（1+tick_threshold）*tick_size
    bid_high=last_bid +（1+ tick_threshold）*tick_size

   #比较新的bid是在此范围，如果在此范围，则保持原来的bid
   #否则更新bid
    if bid_low < bid < bid_high:
       rounded_bid=last_bid
    else:
       rounded_bid=bid
       last_bid=bid
    
    #生成上一次ask的波动区间
    ask_low=last_ask -（1+tick_threshold）*tick_size
    ask_high=last_ask +（1+ tick_threshold）*tick_size

    #比较新的ask是在此范围，如果在此范围，则保持原来的ask
    #否则更新ask
    if ask_low < ask < ask_high:
       rounded_ask=last_ask
    else:
       rounded_ask=ask
       last_ask=ask
    
    ...... 
    #获取对应规则的处理函数 function_handler

   # 传入rounded_bid/rounded_ask,生成最终符合需求的bid_ask报价对


创建于 2017-03-10
著作权归作者所有
