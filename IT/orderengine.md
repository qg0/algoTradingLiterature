
[概述](https://zhuanlan.zhihu.com/FITStory)

## 概述
做市商的定价过程，完整地叙述，就是接受市场价格信息，根据某种预先定义的规则（规则内嵌在定价模块里或者被引用的外部模块中），生成一组或者多组ask/bid价格，经过检验无误后提交给市场下单模块。
这么说比较枯燥，不妨用列表表示。
1. 理论定价（theoretical pricing） : 根据标的资产的价格生成需定价的期权的理论价格
2. 微调（shifting）: 对理论价格进行调整，加上偏差（bias), 这一步也可以叫做微调
3. 生成买卖差价（spreading）: 根据步骤2调整后的理论价格，生成bid/ask 报价。做市商提供的报价包括卖价和买价。
4. 买卖差价再调整（ask/bid shifting）: 根据预定义规则，对bid/ask价格各加上偏差(bias)
5. 调整价格格式（tick rounding）: 根据四舍五入原则对bid/ask价格进行处理, 并且处理锁报价和交叉报价这两种无效报价情况。
6. 检验（verfication）: 最后检验是否符合交易市场的价差要求，输出最终报价bid/ask
可以看到，报价过程是一个流水线。虽然看上去简单，实际却是交易系统的核心。作为高速流动市场上的做市商，她必须能以毫秒级别的速度处理输入报价，定价并输出报价到交易引擎。所以每个步骤写的明确。


[概述](https://zhuanlan.zhihu.com/p/25673286)
## 生成理论价格

之前概括中，没有细说的是一个完整的期权定价过程以标的合约价格，`历史波动率`，`无风险利率`，`股息`（如果有的话）`行权价格和到期时间`为输入，以符合市场规则的期权bid/ask 报价为输出。

所以第一步就是输入标的合约的价格和其他参数，使用定价模块输出理论价格。如果我们约定无风险利率保持在3%，对于期货期权股息可以忽略，到期时间和行权价格在当日都属于不变参数。唯一可能变化的是历史波动率和标的合约价格。历史波动率的话，我们可以认为根据每天的收盘价（或结算价）计算得出。例如如果是还有3个月到期的期货的期权，那么就计算90天的历史波动率。因此在当日交易直到收盘前，历史波动率也是不变的。

唯一可变的就是标的合约的市场价格了。 对于ETF期权来说，就是ETF的价格。对于期货期权来说，就是对应的期货合约价格。例如期权m1705-C-2750 对应的是17年五月份结束交易的豆粕合约。所以标的合约的市场价格被当作理论价格的主要输入变量。

期货期权理论价格的计算，通常用改进过的B-S(中文名毕苏）方程计算即可。理论计算出来的价格与市场上实际交易的价格肯定是有偏差的。这个偏差直接体现在了隐含波动率和计算使用的历史波动率之间的差异。所以在理论价格生成后，下一步就是对理论价格进行微调而不是直接报价。现在我们先集中精力研究如何生成理论价格。

第一种方法是精确定价，这种方法的特点是根据某种模型直接计算出理论价格。例如BS模型等等，用在期权类衍生品上非常合适。模型算法可以放在外部模块中，被定价引擎调用。特点是精确（特别注意，仅仅是理论上的精确，并不代表符合实际市场）。缺点是对模块性能要求很高。实际市场的标的合约价格变动是以毫秒为级别，行情推送则以500毫秒为一个tick。即使其他所有剩下的定价步骤只需要100毫秒，那么在400毫秒中，计算引擎必须调用外部的模块计算一个微分方程。更糟糕的是，由于模块之间的函数调用需要涉及到动态链接库，这本身就需要额外的时间。因此一个精确定价的模块，必须使用C语言或者C++语言编写，并且经过编译器优化后被调用。 目前比较流行的开源模块有基于boost的 QuantLib。链接如下：
a free/open-source library for quantitative finance
如果用户需要非常精确的理论价格，并且程序编写能力非常好，在秒级别的报价中，可以考虑使用这种方法。

第二种方法比较作弊。它假设期权的Delta 和Gamma在一个极短间隔，例如毫秒级别是不变的。因此我们利用最近的历史期权价格和历史Delta, Gamma生成新的期权价格。
具体地说，由于期货合约每天的价格变动在一个区间内，例如结算价的正负4%，历史波动率和其他信息已知，我们完全可以预先计算好对应标的合约每个整数价格，例如2000，2001。。。2010.。。。的期权价格, Delta, Gamma。如果你有兴趣，也可以生成Vega。每个标的合约的价格对应的是一个向量，向量包含了标的合约价格S，理论价格P, 期权的Delta, 期权的Gamma。这些向量存在一个矩阵或者其他快速检索的数据结构中，并在当日交易时提前被调入内存等待使用。
一旦理论价格生成模块获取到最新的标的合约市场价格时，它首先寻找向量组中是否已存在该价格。如果存在，就直接返回。如果不存在，就获取与当前价格最接近的一组向量（例如100.1选择100，100.9选择101，100.5可以选择100或者101），最终通过线性插值计算得出理论价格。这种方式的特点是简单实用，适用于许多简单的金融合约，例如期权。如果实时计算，则非常耗时。计算机科班出身的朋友，一定看出来，这就是经典的空间换时间。使用伪代码显示如下
def theoPriceGen (spotPrice=s):
#使用插值法生成理论价格，输入s为原始价格
    
    #如果存在vector[s]，则直接返回对应的理论价格
    if vector[s] <> NULL
        return vector[s].price
#如果没有s的预存值，则返回与s值最近的一个向量record
    #例如s=100,s0=99，其他值都小于99，因此s与s0之间的距离最近
record=getVector(s)
    delta0=record.delta  #预先设定  
    gamma0=record.gamma #预先设定
    s0=record.s0
    p0=record.p0
#按照delta, gamma的定义计算价格，这里假定这两个参数在短间隔内不变。
    price=p0+delta*(s-s0)+0.5*gamma*(s-s0)**2    
    return price
插值法的特点是快速。特别适合毫秒级别的计算。如果采用字典设计，那么该函数的调用时间实际上是O(1)。粗略地可以理解为常数时间。但是空间代价则是O(n)。粗略可以理解为随着价格个数的增加线性增长。不同于期货，对应于一份期货合约，期货期权可能有几十种合约。那么对应市场上几百种期货合约，期货期权就会有上万种。每种合约的当日价格变动就有几十个间隔单位。好在现代服务器高达100GB以上的内存可以同时保持这么多期权向量组。
第三种方法适用于一类特殊的产品，市场上叫做Delta One。意思是衍生品价格变动值和标的资产价格变动值呈简单的线性关系，没有二次或者二次以上的项。使用伪代码表示如下
def theoPriceGen(spot=s):
    #a,b 为预先定义
    price=as+b
    return price
可以看到，这种方式比插值法还简单。实际使用中，比较适合两种极为相似的产品。
第四种方法比较特殊。需要计算的期权价格可以直接从市场上的另一种期权的价格得到。
def theoPriceGen4(priceOnMkt):
  
    #definedShift 是预先定义的偏移量
    #priceOnMkt 是从市场上获取的另一种期权的价格
    price=priceOnMkt+definedShift
    return price
我们可以想象一个场景，市场上有一对极其相似的期权合约，两者之间的价格差稳定在一个值上。因此得知其中一个合约的价格，就可以直接计算出另一个合约的价格。那么第四种方法就可以用于这种情况。
创建于 2017-03-10
著作权归作者所有
